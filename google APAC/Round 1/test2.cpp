#include<cmath>#include<algorithm>#include<vector>using namespacestd;#include"fin_recipes.h"const doubleERROR=1e30;doublecashflowirrdiscrete(constvector<double>&cflowtimes,constvector<double>&cflowamounts) {// simple minded irr function. Will find one root (if it exists.)// adapted from routine in Numerical Recipes in C.if(cflowtimes.size()!=cflowamounts.size())returnERROR;const doubleACCURACY= 1.0e5;const intMAXITERATIONS= 50;doublex1= 0.0;doublex2= 0.2;// create an initial bracket, with a root somewhere between bot,topdoublef1=cashflowpvdiscrete(cflowtimes,cflowamounts,x1);doublef2=cashflowpvdiscrete(cflowtimes,cflowamounts,x2);inti;for(i=0;i<MAXITERATIONS;i++) {if( (f1*f2)<0.0) {break; };//if(fabs(f1)<fabs(f2)) {f1=cashflowpvdiscrete(cflowtimes,cflowamounts,x1+=1.6*(x1x2));}else{f2=cashflowpvdiscrete(cflowtimes,cflowamounts,x2+=1.6*(x2x1));};};if(f2*f1>0.0) {returnERROR; };doublef=cashflowpvdiscrete(cflowtimes,cflowamounts,x1);doublertb;doubledx=0;if(f<0.0) {rtb=x1;dx=x2x1;}else{rtb=x2;dx=x1x2;};for(i=0;i<MAXITERATIONS;i++){dx*= 0.5;doublexmid=rtb+dx;doublefmid=cashflowpvdiscrete(cflowtimes,cflowamounts,xmid);if(fmid<=0.0) {rtb=xmid; }if( (fabs(fmid)<ACCURACY)jj(fabs(dx)<ACCURACY) )returnxmid;};returnERROR;// error.};C++Code 3.2:Estimation of the internal rate of return31
